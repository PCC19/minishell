INIT TERMINAL

LOOP ENTRADA
	UP
		pega history
		mostra na tela
	DN
		pega history
		mostra na tela
	BS
		apaga char anterior
	CHAR
		mostra
		adiciona a linha
	retorna LINHA

PARSE LINHA
	separa por ;
	PARSE PIPELINE
		separa por |
		PARSE COMMAND
			trata ' " e $
			pega comando+args
				ou
			pega redirects int
			pega redirects out
			EXECUTA
				BUILT IN
				PROGRAMA
					procura bin no PATH
					faz fork e executa
		encadeia para o proximo do pipe
LOOP INICIO


----------------------------------------------------------------------
Le  char: 
se ‘ ou “ 
    update estado 
se char 
    trata de acordo com estado 
    NORMAL: copia 
    ‘: copia 
    “: copia 
se $; 
trata de acordo com estado 
    NORMAL: expande 
    ‘: copia 
    “: expande 
incrementa 

----------------------------------------------------------------------

estado = NORMAL
loop ate chegar no fim da string linha
	se ' ou " muda estado e incrementa
	se char dif $
		copia char
		incr
	se $ e estado == NORMAL ou estado = "
		incr
		EXPANDE
		incrementa gde
	else
		copia char
		incrementa
----------------------------------------------------------------------

loop por caracter
	se tem < 
		avanca ignorando ' '
		pega proxima substr ate ' ' e faz redirect
	se tem >
		avanca 1
		se tem > de novo
			muda flag
			avanca ignorando ' '
			pega proxima substr ate ' ' e faz redirect
	se tem ' '
		avanca ingnorando ' '
		pega substr ate '<>0' e seta filename
			se ja houver filename: erro !


----------------------------------------------------------------------
Pula linha e printa >
le o que for digitado na linha (com backspace)
Se for difernte de [word]
	acrescenta num array_bi
	segue loop
Apos terminar leitura -> array_bi vira input do comando
	(fazer um printf para o fd de entrada ?)

parse:
	fazer parse normal
	se tiver <<
		executa rotina





