srcs/bye.c:	tcsetattr(0, TCSANOW, &v->old);
srcs/bye.c:	u_free_array_bi(v->env);
srcs/bye.c:	u_free_array_bi(v->path);
srcs/bye.c:	while (i < 50 && i < v->qtd_hist)
srcs/bye.c:		free(v->hist[i]);
srcs/bye.c:	free(v->prompt);
srcs/bye.c:	free(v->curr_comand);
srcs/bye.c:	ft_bzero(v->ret2, ft_strlen(v->ret2));
srcs/bye.c:	free(v->ret2);
srcs/create_prompt.c:	free(v->prompt);
srcs/create_prompt.c:	v->prompt = ft_strdup(aux);
srcs/exec_com2.c:		if (is_abs_path(v->cmd.cmd_args[0]))
srcs/exec_com2.c:			r = execve(v->filename, &v->cmd.cmd_args[0], v->env);
srcs/exec_com2.c:			r = execve(v->filename, &v->cmd.cmd_args[0], v->env);
srcs/exec_com2.c:				if (v-pa
srcs/exec_com2.c:	if (v->cmd.cmd_args[1] != NULL )
srcs/exec_com2.c:		if (v->cmd.cmd_args[1][0] == '~' && v->cmd.cmd_args[1][1] != '~')
srcs/exec_com2.c:			v->cmd.cmd_args[1] = (ft_strjoin(loc_var("HOME",v),&v->cmd.cmd_args[1][1]));
srcs/exec_com2.c://		printf("cmd_args[0]: |%s|\n", v->cmd.cmd_args[0]);
srcs/exec_com2.c://		printf("cmd_args[1]: |%s|\n", v->cmd.cmd_args[1]);
srcs/exec_com2.c:	//v->cmd.cmd_args[0] = get_last_path(v->cmd.cmd_args[0]);
srcs/exec_com2.c:	v->cmd.cmd_args[0] = get_last_path2(v->cmd.cmd_args[0]);
srcs/exec_com2.c://		printf("cmd_args[0]: |%s|\n", v->cmd.cmd_args[0]);
srcs/exec_com2.c://		printf("cmd_args[1]: |%s|\n", v->cmd.cmd_args[1]);
srcs/exec_com2.c:	while (v->path[i] != NULL)
srcs/exec_com2.c:		//printf("%d , %s\n",i,v->path[i]);
srcs/exec_com2.c:		aux = ft_strdup(v->path[i]);
srcs/exec_com2.c:		command = ft_strjoin(aux, v->cmd.cmd_args[0]);
srcs/exec_com2.c:			printf("cmd_args[0]: |%s|\n", v->cmd.cmd_args[0]);
srcs/exec_com2.c:			printf("cmd_args[1]: |%s|\n", v->cmd.cmd_args[1]);
srcs/exec_com2.c:		r = execve(command, &v->cmd.cmd_args[0], v->env);
srcs/execute_command.c:	if (ft_strncmp(v->cmd.filename, "pwd", 3) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 3)
srcs/execute_command.c:	else if (ft_strncmp(v->cmd.filename, "cd", 2) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 2)
srcs/execute_command.c:	else if (ft_strncmp(v->cmd.filename, "echo", 4) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 4)
srcs/execute_command.c:	else if (ft_strncmp(v->cmd.filename, "export", 6) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 6)
srcs/execute_command.c:	else if (ft_strncmp(v->cmd.filename, "unset", 5) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 5)
srcs/execute_command.c:	else if (ft_strncmp(v->cmd.filename, "env", 3) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 6)
srcs/execute_command.c:	else if (ft_strncmp(v->cmd.filename, "exit", 4) == 0
srcs/execute_command.c:		&& ft_strlen(v->cmd.filename) == 4)
srcs/execute_command.c:		if (v->ret_last == 0)
srcs/execute_command.c:			v->cmd.ret_status = fork_process(v);
srcs/execute_command.c:	while (v->env[i])
srcs/execute_command.c:	if (v->cmd.cmd_args[1] != 0)
srcs/execute_command.c:		while (v->env[i] != 0)
srcs/execute_command.c:			if (ft_strncmp(v->env[i], var, ft_strlen(var)) != 0)
srcs/execute_command.c:				new[k++] = ft_strdup(v->env[i]);
srcs/execute_command.c:		aux = v->env;
srcs/execute_command.c:		v->env = new;
srcs/execute_command.c:		free_array((void*)v->path);
srcs/execute_command.c:	if (v->cmd.cmd_args[1] != NULL )
srcs/execute_command.c:		if (v->cmd.cmd_args[1][0] == '~' && v->cmd.cmd_args[1][1] != '~')
srcs/execute_command.c:			v->cmd.cmd_args[1] = (ft_strjoin(loc_var("HOME",v),&v->cmd.cmd_args[1][1]));
srcs/execute_command.c://		printf("cmd_args[0]: |%s|\n", v->cmd.cmd_args[0]);
srcs/execute_command.c://		printf("cmd_args[1]: |%s|\n", v->cmd.cmd_args[1]);
srcs/execute_command.c:	//v->cmd.cmd_args[0] = get_last_path(v->cmd.cmd_args[0]);
srcs/execute_command.c:	v->cmd.cmd_args[0] = get_last_path2(v->cmd.cmd_args[0]);
srcs/execute_command.c://		printf("cmd_args[0]: |%s|\n", v->cmd.cmd_args[0]);
srcs/execute_command.c://		printf("cmd_args[1]: |%s|\n", v->cmd.cmd_args[1]);
srcs/execute_command.c:	while (v->path[i] != NULL)
srcs/execute_command.c:		//printf("%d , %s\n",i,v->path[i]);
srcs/execute_command.c:		aux = ft_strdup(v->path[i]);
srcs/execute_command.c:		command = ft_strjoin(aux, v->cmd.cmd_args[0]);
srcs/execute_command.c:			printf("cmd_args[0]: |%s|\n", v->cmd.cmd_args[0]);
srcs/execute_command.c:			printf("cmd_args[1]: |%s|\n", v->cmd.cmd_args[1]);
srcs/execute_command.c:		r = execve(command, &v->cmd.cmd_args[0], v->env);
srcs/exit_msh.c:	v->flag_exit = 1;
srcs/expand.c:	*substr = ft_strchr(v->env[q], '=');
srcs/expand.c:	aux = handle_interrogation(v->cmd.ret_status, line[k], &substr, &k);
srcs/expand.c:		while (v->env[++q] != 0)
srcs/expand.c:			if (!ft_strncmp(line, v->env[q], k))
srcs/expand.c:	ft_memcpy(&v->expanded[(*j)], substr, ft_strlen(substr));
srcs/export_var.c:	if (v->cmd.cmd_args[1] != 0)
srcs/export_var.c:		while (v->env[len_arr])
srcs/export_var.c:		while (v->env[i] != 0)
srcs/export_var.c:			new[i] = ft_strdup(v->env[i]);
srcs/export_var.c:		new[i] = ft_strdup(v->cmd.cmd_args[1]);
srcs/export_var.c:		aux = v->env;
srcs/export_var.c:		v->env = new;
srcs/gets.c:	if (v->cmd.cmd_args[1] == NULL)
srcs/gets.c:	else if (v->cmd.cmd_args[1][0] == '~')
srcs/gets.c:		resp = chdir(ft_strjoin(loc_var("HOME",v),&v->cmd.cmd_args[1][1]));
srcs/gets.c:		resp = chdir(v->cmd.cmd_args[1]);
srcs/gets.c:		ptr = ft_strjoin(aux, v->cmd.cmd_args[1]);
srcs/gets.c:	if (v->cmd.cmd_args[1] != NULL)
srcs/gets.c:		while (v->cmd.cmd_args[i] != 0)
srcs/gets.c:			if (i > 1 && v->cmd.cmd_args[i][k] != 0 && cont == 1)
srcs/gets.c:			while (v->cmd.cmd_args[i][k] != 0)
srcs/gets.c:				if (v->cmd.cmd_args[i][0] == '-'
srcs/gets.c:					&& v->cmd.cmd_args[i][1] == 'n' && cont == 0)
srcs/gets.c:					//if (v->cmd.cmd_args[i][k] != '"'
srcs/gets.c:					//	&& v->cmd.cmd_args[i][k] != '\'')
srcs/gets.c:						ft_putchar(v->cmd.cmd_args[i][k]);
srcs/gets.c:	if (v->cmd.cmd_args[1] != 0)
srcs/gets.c:		var = ft_strdup(v->cmd.cmd_args[1]);
srcs/gets.c:	if (v->cmd.cmd_args[1] == NULL)
srcs/gets.c:	return (v->cmd.ret_status);
srcs/init_cmd_args.c:	//v->cmd = (t_cmd){0};
srcs/init_cmd_args.c:	v->cmd.cmd_args = (char **)safe_malloc((0 + 1) * sizeof(char *));
srcs/init_cmd_args.c:	v->cmd.cmd_args[0] = NULL;
srcs/initialize.c:		v->hist[i] = ft_strdup(envp);
srcs/initialize.c:	v->hist[i] = 0;
srcs/initialize.c:	v->path = ft_split(aux, ':');
srcs/initialize.c:	v->env = (char **)safe_malloc((len_arr + 1) * sizeof(char *));
srcs/initialize.c:		v->env[i] = ft_strdup(envp[i]);
srcs/initialize.c:	v->env[i] = 0;
srcs/initialize.c:	v->cmd.filename = 0;
srcs/initialize.c:	//v->cmd.cmd_args = 0;
srcs/initialize.c:	v->cmd.fd_in_red = -1;
srcs/initialize.c:	v->cmd.fd_out_red = -1;
srcs/initialize.c:	v->cmd.fd_in = -1;
srcs/initialize.c:	v->cmd.fd_out = -1;
srcs/initialize.c:	v->cmd.save_in = dup(STDIN_FILENO);
srcs/initialize.c:	v->cmd.save_out = dup(STDOUT_FILENO);
srcs/initialize.c:	v->cmd.fd_in = STDIN_FILENO;
srcs/loc_var.c:	while (v->env[i] != NULL && ft_strncmp(v->env[i], var, n))
srcs/loc_var.c:	if (v->env[i] != NULL)
srcs/loc_var.c:		return (&v->env[i][n + 1]);
srcs/main.c:	ft_putstr_fd(v->curr_comand,1);
srcs/main.c:	v->cmd.ret_status = 127;
srcs/main.c:	v->flag_exit = 1;
srcs/main.c:	ft_putnbr_fd(v->cmd.ret_status,1);
srcs/main.c:	v->ret_last = 1;
srcs/main.c:	ft_putstr_fd(v->prompt,1);
srcs/parse_cmd_args.c:	ff(v->expanded, k);
srcs/parse_cmd_args.c:	copy_until(aux, v->expanded, c, k);
srcs/parse_cmd_args.c:		while (v->cmd.cmd_args[len_arr])
srcs/parse_cmd_args.c:		while (v->cmd.cmd_args[i] != 0)
srcs/parse_cmd_args.c:			new[i] = ft_strdup(v->cmd.cmd_args[i]);
srcs/parse_cmd_args.c:		aux = v->cmd.cmd_args;
srcs/parse_cmd_args.c:		v->cmd.cmd_args = new;
srcs/parse_cmd_args.c:	copy_until(aux, v->expanded, "\"\'<>", k);
srcs/parse_cmd_args.c:	//v->cmd.cmd_args = ft_split3(cmdeargs, ' ');
srcs/parse_cmd_args.c:		//u_print_array_bi(v, v->cmd.cmd_args);
srcs/parse_cmd_args.c:	v->cmd.filename = ft_strdup(v->cmd.cmd_args[0]);
srcs/parse_cmd_lines.c:	if (v->cmd.ret_status == -1)
srcs/parse_cmd_lines.c:		free(v->curr_comand);
srcs/parse_cmd_lines.c:		ft_bzero(v->ret, 2048);
srcs/parse_cmd_lines.c:		v->pidc = getpid();
srcs/parse_cmd_lines.c:		kill(v->pidc, SIGKILL);
srcs/parse_cmd_lines.c:	check_n_free(v->curr_comand);
srcs/parse_cmd_lines.c:	v->curr_comand = ft_strdup(aux[i]);
srcs/parse_cmd_lines.c:	v->cmd_lines[i] = ft_strtrim(s, " ");
srcs/parse_cmd_lines.c:	parse_pipelines(v, v->cmd_lines[p]);
srcs/parse_cmd_lines.c:	u_free_array_bi(v->pipelines);
srcs/parse_cmd_lines.c:	v->cmd_lines = (char **)safe_malloc(sizeof(char *) * (n + 1));
srcs/parse_cmd_lines.c:	while(aux[i] && v->flag_exit == 0)
srcs/parse_cmd_lines.c:			//check_n_free(v->curr_comand);
srcs/parse_cmd_lines.c:			//v->curr_comand = ft_strdup(aux[i]);
srcs/parse_cmd_lines.c:			v->cmd_lines[i] = ft_strtrim(s, " ");
srcs/parse_cmd_lines.c:			parse_pipelines(v, v->cmd_lines[p]);
srcs/parse_cmd_lines.c:			u_free_array_bi(v->pipelines);
srcs/parse_cmd_lines.c:	v->cmd_lines[p] = 0;
srcs/parse_cmd_lines.c:		free(v->cmd_lines[z]);
srcs/parse_cmd_lines.c:	free(v->cmd_lines);
srcs/parse_cmd_lines.c:	//v->cmd = (t_cmd){0};
srcs/parse_cmd_lines.c:	v->cmd_lines = (char **)safe_malloc(sizeof(char *)
srcs/parse_cmd_lines.c:	while (aux[i] && v->flag_exit == 0)
srcs/parse_cmd_lines.c:			check_n_free(v->curr_comand);
srcs/parse_cmd_lines.c:			v->curr_comand = ft_strdup(aux[i]);
srcs/parse_cmd_lines.c:			v->cmd_lines[i] = ft_strtrim(s, " ");
srcs/parse_cmd_lines.c:			parse_pipelines(v, v->cmd_lines[p]);
srcs/parse_cmd_lines.c:			u_free_array_bi(v->pipelines);
srcs/parse_cmd_lines.c:			if (v->cmd.ret_status == -1)
srcs/parse_cmd_lines.c:				free(v->curr_comand);
srcs/parse_cmd_lines.c:				ft_bzero(v->ret,2048);
srcs/parse_cmd_lines.c:				v->pidc = getpid();
srcs/parse_cmd_lines.c:				kill(v->pidc, SIGKILL);
srcs/parse_cmd_lines.c:	v->cmd_lines[p] = 0;
srcs/parse_cmd_lines.c:		free(v->cmd_lines[i]);
srcs/parse_cmd_lines.c:	free(v->cmd_lines);
srcs/parse_in_red.c:	ff(v->expanded, k);
srcs/parse_in_red.c:	copy_until(file_redir, v->expanded, " <>", k);
srcs/parse_in_red.c:	v->cmd.fd_in_red = open(file_redir, O_RDONLY | O_CREAT);
srcs/parse_in_red.c:	dup2(v->cmd.fd_in_red, in);
srcs/parse_in_red.c:	close(v->cmd.fd_in_red);
srcs/parse_out_red.c:	ff(v->expanded, k);
srcs/parse_out_red.c:	if (v->expanded[*k] == '>')
srcs/parse_out_red.c:		ff(v->expanded, k);
srcs/parse_out_red.c:	copy_until(file_redir, v->expanded, " <>", k);
srcs/parse_out_red.c:	v->cmd.fd_out_red = open(file_redir, flags, 0777);
srcs/parse_out_red.c:	if (v->cmd.fd_out_red == -1)
srcs/parse_out_red.c:		v->flag_perm_denied = 1;
srcs/parse_out_red.c:		v->cmd.ret_status = 1;
srcs/parse_out_red.c:	dup2(v->cmd.fd_out_red, out);
srcs/parse_out_red.c:	close(v->cmd.fd_out_red);
srcs/parse_pipelines.c:	close(v->cmd.save_in);
srcs/parse_pipelines.c:	close(v->cmd.save_out);
srcs/parse_pipelines.c:	close(v->cmd.pipe[0]);
srcs/parse_pipelines.c:	close(v->cmd.pipe[1]);
srcs/parse_pipelines.c:	v->pipelines[i] = 0;
srcs/parse_pipelines.c:	v->pipelines[i] = ft_strtrim(s, " ");
srcs/parse_pipelines.c:	parse_s(v, v->pipelines[i]);
srcs/parse_pipelines.c:	pipe(v->cmd.pipe);
srcs/parse_pipelines.c:	v->cmd.fd_out = v->cmd.pipe[PIPE_IN];
srcs/parse_pipelines.c:	fd_handler(v->cmd.fd_in, v->cmd.fd_out);
srcs/parse_pipelines.c:	close(v->cmd.fd_out);
srcs/parse_pipelines.c:	if (v->cmd.fd_in != 0)
srcs/parse_pipelines.c:		close(v->cmd.fd_in);
srcs/parse_pipelines.c:	v->cmd.fd_in = v->cmd.pipe[PIPE_OUT];
srcs/parse_pipelines.c:	dup2(v->cmd.save_in, STDIN_FILENO);
srcs/parse_pipelines.c:	dup2(v->cmd.save_out, STDOUT_FILENO);
srcs/parse_pipelines.c:	free(v->cmd.filename);
srcs/parse_pipelines.c:	v->cmd.filename = NULL;
srcs/parse_pipelines.c:	free(v->expanded);
srcs/parse_pipelines.c:	v->expanded = NULL;
srcs/parse_pipelines.c:	u_free_array_bi(v->cmd.cmd_args);
srcs/parse_pipelines.c:	v->pipelines = (char **)safe_malloc(sizeof(char *) * (n + 1));
srcs/parse_pipelines.c:	while (aux[i] && v->flag_exit == 0)
srcs/parse_pipelines.c:		v->pipelines[i] = ft_strtrim(s, " ");
srcs/parse_pipelines.c:		parse_s(v, v->pipelines[i]);
srcs/parse_pipelines.c:		pipe(v->cmd.pipe);
srcs/parse_pipelines.c:		v->cmd.fd_out = v->cmd.pipe[PIPE_IN];
srcs/parse_pipelines.c:		fd_handler(v->cmd.fd_in, v->cmd.fd_out);
srcs/parse_pipelines.c:		check_n_free(v->curr_comand);
srcs/parse_pipelines.c:		v->curr_comand = ft_strdup(v->cmd.filename);
srcs/parse_pipelines.c:		if (v->flag_perm_denied == 0)
srcs/parse_pipelines.c:		v->flag_perm_denied = 0;
srcs/parse_pipelines.c:		close(v->cmd.fd_out);
srcs/parse_pipelines.c:		if (v->cmd.fd_in != 0)
srcs/parse_pipelines.c:			close(v->cmd.fd_in);
srcs/parse_pipelines.c:		v->cmd.fd_in = v->cmd.pipe[PIPE_OUT];
srcs/parse_pipelines.c:		dup2(v->cmd.save_in, STDIN_FILENO);
srcs/parse_pipelines.c:		dup2(v->cmd.save_out, STDOUT_FILENO);
srcs/parse_pipelines.c:		free(v->cmd.filename);
srcs/parse_pipelines.c:		v->cmd.filename = NULL;
srcs/parse_pipelines.c:		free(v->expanded);
srcs/parse_pipelines.c:		v->expanded = NULL;
srcs/parse_pipelines.c:		u_free_array_bi(v->cmd.cmd_args);
srcs/parse_pipelines.c:		if (v->cmd.ret_status == -1)
srcs/parse_pipelines.c:			free(v->curr_comand);
srcs/parse_pipelines.c:			ft_bzero(v->ret,2048);
srcs/parse_redirects.c:	while (v->expanded[k] != 0)
srcs/parse_redirects.c:		if (v->expanded[k] == '<')
srcs/parse_redirects.c:		else if (v->expanded[k] == '>')
srcs/parse_redirects.c:		else if (v->expanded[k] == SPC)
srcs/parse_redirects.c:			ff(v->expanded, &k);
srcs/parse_s.c:	v->expanded = (char *)ft_calloc(MIL, sizeof(char));
srcs/parse_s.c:			ft_memcpy(&v->expanded[j], &linha[i], 2);
srcs/redirect_handler.c:	while (v->expanded[k] != 0)
srcs/redirect_handler.c:		if (v->expanded[k] == '\"')
srcs/redirect_handler.c:		else if (v->expanded[k] == '\'')
srcs/redirect_handler.c:		else if (v->expanded[k] == '<')
srcs/redirect_handler.c:			parse_in_red(v, &k, v->cmd.fd_in);
srcs/redirect_handler.c:		else if (v->expanded[k] == '>')
srcs/redirect_handler.c:			parse_out_red(v, &k, v->cmd.fd_out);
srcs/redirect_handler.c:		else if (v->expanded[k] == SPC)
srcs/redirect_handler.c:			ff(v->expanded, &k);
srcs/redirect_handler.c:	if (i == 0 && v->cmd.fd_in_red == -1)
srcs/redirect_handler.c:		v->cmd.fd_in = STDIN_FILENO;
srcs/redirect_handler.c:	if (i == (n - 1) && v->cmd.fd_out_red == -1)
srcs/redirect_handler.c:		v->cmd.fd_out = STDOUT_FILENO;
srcs/reset_flags.c:	v->curr_comand = ft_strdup("");
srcs/reset_flags.c:	v->qtd_hist = 0;
srcs/reset_flags.c:	v->savein = dup(STDIN_FILENO);
srcs/reset_flags.c:	v->saveout = dup(STDOUT_FILENO);
srcs/reset_flags.c:	v->in_fd = STDIN_FILENO;
srcs/reset_flags.c:	v->cmd.ret_status = EXIT_SUCCESS;
srcs/reset_flags.c:	v->r_command = 0;
srcs/reset_flags.c:	v->ret2 = ft_strdup("");
srcs/reset_flags.c:	v->prompt = ft_strdup("");
srcs/reset_flags.c:	v->posic_string = 0;
srcs/reset_flags.c:	v->pid = getpid();
srcs/reset_flags.c:	//printf("pid %d\n", v->pid);
srcs/set_return_status.c:		v->cmd.ret_status = EXIT_SUCCESS;
srcs/set_return_status.c:		v->cmd.ret_status = status;
srcs/update_env_var.c:	while (v->env[i] != NULL && ft_strncmp(v->env[i], var, n))
srcs/update_env_var.c:	if (v->env[i] != NULL)
srcs/update_env_var.c:		free(v->env[i]);
srcs/update_env_var.c:		v->env[i] = ft_strjoin(aux, buf);
srcs/u_print_array_bi.c:	if (fcntl(v->cmd.save_out, F_GETFD) != -1)
srcs/u_print_array_bi.c:		aux = v->cmd.save_out;
srcs/u_print_array_bi.c:			//dprintf(v->cmd.save_out,"|%s|\n", (s[i]));
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"__________________________________________\n");
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"   STRUCT CMD    \n");
srcs/u_print_struct_cmd.c:	if (v->cmd.filename != NULL)
srcs/u_print_struct_cmd.c:		dprintf(v->cmd.save_out,"filename:\t\t|%s|\n", v->cmd.filename);
srcs/u_print_struct_cmd.c:		dprintf(v->cmd.save_out,"filename:\t\t|vazio|\n");
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"cmd_args:\n");
srcs/u_print_struct_cmd.c:	u_print_array_bi(v, v->cmd.cmd_args);
srcs/u_print_struct_cmd.c:	//dprintf(v->cmd.save_out,"|%s|:\n", v->cmd.cmd_args[0]);
srcs/u_print_struct_cmd.c:	//if (v->cmd.cmd_args[0] != NULL && !strcmp(v->cmd.cmd_args[0], ""))
srcs/u_print_struct_cmd.c:	//	u_print_array_bi(v, v->cmd.cmd_args);
srcs/u_print_struct_cmd.c:	//	dprintf(v->cmd.save_out,"\n");
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"fd_in_red: %d\t\t fd_out_red: %d\n", v->cmd.fd_in_red, v->cmd.fd_out_red);
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"pipe[in]: %d\t\t pipe[out]: %d\n", v->cmd.pipe[PIPE_IN], v->cmd.pipe[PIPE_OUT]);
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"fd_in: %d\t\t fd_out: %d\n", v->cmd.fd_in, v->cmd.fd_out);
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"ret_status:\t\t %d\n",v->cmd.ret_status);
srcs/u_print_struct_cmd.c:	dprintf(v->cmd.save_out,"__________________________________________\n");
